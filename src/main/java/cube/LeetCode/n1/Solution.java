package cube.LeetCode.n1;

import java.util.HashMap;

class Solution {

    public int[] twoSum(int[] nums, int target) {
        // return slowSolution(nums, target);
        return fastSolution(nums, target);
    }

    /**
     * Метод находит два числа в переданном массиве, сумма которых равна заданному
     * числу (target).
     * Возвращает индексы этих двух чисел.
     *
     * <p>
     * <b>Описание алгоритма:</b>
     * </p>
     * Метод реализует простой (наивный) перебор всех возможных пар элементов
     * массива:
     * <ul>
     * <li>Используется два вложенных цикла для проверки всех возможных комбинаций
     * чисел.</li>
     * <li>Если сумма текущей пары чисел равна target, сохраняются их индексы.</li>
     * <li>Так как задача гарантирует единственное решение, последняя найденная пара
     * возвращается.</li>
     * </ul>
     *
     * <p>
     * <b>Сложность алгоритма:</b>
     * </p>
     * <ul>
     * <li>Временная сложность: O(n²) – из-за двух вложенных циклов, проходящих по
     * массиву.</li>
     * <li>Дополнительная память: O(1) – используется только несколько
     * переменных.</li>
     * </ul>
     *
     * @param nums   Массив целых чисел, в котором гарантированно существует одна
     *               пара чисел, сумма которых равна target.
     * @param target Целевое число, сумма двух чисел из массива должна быть равна
     *               ему.
     * @return Массив из двух чисел, содержащий индексы найденных элементов.
     * @throws IllegalArgumentException Если пара чисел не найдена (хотя задача
     *                                  гарантирует наличие решения).
     */
    public int[] slowSolution(int[] nums, int target) {
        int ii = -1, jj = -1; // Начальные индексы
        int len = nums.length;

        for (int i = 0; i < len - 1; ++i) {
            for (int j = i + 1; j < len; ++j) {
                if (nums[i] + nums[j] == target) {
                    ii = i;
                    jj = j;
                    return new int[] { ii, jj };
                }
            }
        }

        throw new IllegalArgumentException("Решение не найдено, хотя оно должно быть по условию задачи.");
    }

    /**
     * Метод находит два числа в переданном массиве, сумма которых равна заданному
     * числу (target),
     * и возвращает индексы этих чисел. Используется хеш-таблица (HashMap) для
     * ускорения поиска.
     *
     * <p>
     * <b>Описание алгоритма:</b>
     * </p>
     * Метод использует один проход (O(n)) и хеш-таблицу для хранения уже
     * просмотренных элементов:
     * <ul>
     * <li>Создается HashMap, где ключ – число из массива, а значение – его
     * индекс.</li>
     * <li>Во время прохода по массиву вычисляется разница (target - nums[i]).</li>
     * <li>Если эта разница уже есть в HashMap, значит, найдена пара чисел, и мы
     * сразу возвращаем их индексы.</li>
     * <li>Иначе текущее число добавляется в HashMap.</li>
     * </ul>
     *
     * <p>
     * <b>Сложность алгоритма:</b>
     * </p>
     * <ul>
     * <li>Временная сложность: O(n) – всего один проход по массиву.</li>
     * <li>Дополнительная память: O(n) – для хранения элементов в HashMap.</li>
     * </ul>
     *
     * @param nums   Массив целых чисел, в котором гарантированно существует одна
     *               пара чисел, сумма которых равна target.
     * @param target Целевое число, сумма двух чисел из массива должна быть равна
     *               ему.
     * @return Массив из двух чисел, содержащий индексы найденных элементов.
     * @throws IllegalArgumentException Если пара чисел не найдена (хотя задача
     *                                  гарантирует наличие решения).
     */
    public int[] fastSolution(int[] nums, int target) {
        HashMap<Integer, Integer> hash = new HashMap<>();

        for (int i = 0; i < nums.length; ++i) {
            int complement = target - nums[i]; // Ищем число, которое в сумме с текущим даст target

            if (hash.containsKey(complement)) {
                return new int[] { hash.get(complement), i }; // Найдена пара чисел
            }

            hash.put(nums[i], i); // Сохраняем число и его индекс в HashMap
        }

        throw new IllegalArgumentException("Решение не найдено, хотя оно должно быть по условию задачи.");
    }

}
